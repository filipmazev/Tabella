using System.ComponentModel.DataAnnotations;
using System.Collections.Concurrent;
using System.Security.Cryptography;
using Tabella.Utility.Attributes;
using System.Reflection;
using Tabella._Common;
using System.Text;

namespace Tabella.Data.Core;

/// <summary>
/// Base class for import models that generate unique keys based on composite properties.
/// </summary>
public abstract class ImportModel
{
    /// <summary>
    /// The generated unique key for this import model instance.
    /// </summary>
    public UInt128? Key { get; private set; }
    
    /// <summary>
    /// The generated lookup key for this import model instance.
    /// </summary>
    public UInt128? LookupKey { get; private set; }
    
    /// <summary>
    /// The header names used to generate the key, if applicable.
    /// </summary>
    public string? KeyHeaderNames { get; private set; }
    
    /// <summary>
    /// The row index from the source tabular data, if applicable.
    /// </summary>
    public int? RowIndex { get; private set; }

    private static readonly ConcurrentDictionary<Type, PropertyInfo[]> KeyPropertiesCache = new();
    private static readonly ConcurrentDictionary<Type, Dictionary<string, (PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[]>> LookupKeyPropertiesCache = new();
    private static readonly ConcurrentDictionary<Type, Dictionary<string, PropertyInfo>> LookupKeyTargetPropertiesCache = new();
    private static readonly ConcurrentDictionary<Type, PropertyInfo[]> OwnPropertiesCache = new();
    
    private const string AutoGeneratedHeader = "<auto-generated>";
    
    /// <summary>
    /// Concatenates all public property values for debugging purposes.
    /// </summary>
    public override string ToString()
    {
        PropertyInfo[] properties = GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
        IEnumerable<string> values = properties.Select(p => p.GetValue(this)?.ToString() ?? string.Empty);
        return string.Join(" ", values);
    }
    
    /// <summary>
    /// Generates all keys for this instance.
    /// </summary>
    public void GenerateKeys(int? rowIndex = null)
    {
        RowIndex = rowIndex;

        PropertyInfo[] keyProperties = GetFilteredKeyProperties();

        KeyBuildResult keyBuildResult = BuildKey(keyProperties, rowIndex, forLookupKey: false, includeHeaders: true);

        Key = keyBuildResult.Key;
        KeyHeaderNames = keyBuildResult.HeaderNames.Length == 0
            ? null
            : string.Join(", ", keyBuildResult.HeaderNames);

        LookupKey = BuildKey(keyProperties, rowIndex, forLookupKey: true, includeHeaders: false).Key;

        Dictionary<string, (PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[]> lookupGroups = GetLookupKeyProperties();

        foreach ((string targetProperty, (PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[] groupParts) in lookupGroups)
        {
            UInt128? groupKey = BuildLookupGroupKey(groupParts);
            SetLookupKeyValue(targetProperty, groupKey);
        }
    }
    
    private KeyBuildResult BuildKey(
        PropertyInfo[] properties,
        int? rowIndex,
        bool forLookupKey,
        bool includeHeaders)
    {
        if (properties.Length == 0)
        {
            PropertyInfo[] ownProps = GetOwnProperties();
            if (ownProps.Length == 0)
            {
                if (forLookupKey) 
                    return new KeyBuildResult(null, []);

                UInt128 random = rowIndex.HasValue
                    ? GenerateHash([$"{nameof(RowIndex)}:{rowIndex.Value}"])
                    : GenerateRandomUInt128();

                return new KeyBuildResult(random, includeHeaders ? [AutoGeneratedHeader] : []);
            }

            properties = ownProps;
        }

        if (forLookupKey)
        {
            properties = properties
                .Where(p => p.GetCustomAttribute<CompositeKeyPartAttribute>()?.ExcludeFromLookupKey == false)
                .ToArray();

            if (properties.Length == 0)
                return new KeyBuildResult(null, []);
        }

        properties = properties.OrderBy(p => p.Name).ToArray();

        string[] tokens = properties
            .Select(p => GetKeyToken(p, this))
            .ToArray();
        
        if (!forLookupKey && tokens.All(t => t.EndsWith(":")))
            return new KeyBuildResult(GenerateRandomUInt128(), includeHeaders ? [AutoGeneratedHeader] : []);
        
        UInt128 key = GenerateHash(tokens);

        string[] headers = includeHeaders
            ? properties
                .Select(p => p.GetCustomAttribute<CompositeKeyPartAttribute>()?.HeaderName ?? string.Empty)
                .Where(h => !string.IsNullOrWhiteSpace(h))
                .ToArray()
            : [];

        return new KeyBuildResult(key, headers);
    }
    
    private UInt128? BuildLookupGroupKey((PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[] parts)
    {
        string[] tokens = parts
            .OrderBy(p => p.Prop.Name)
            .Select(p => GetKeyTokenForLookupGroup(p.Prop, p.Attr, this))
            .ToArray();

        if (tokens.All(string.IsNullOrWhiteSpace) || tokens.All(t => t.EndsWith(":")))
            return null;

        return GenerateHash(tokens);
    }

    /// <summary>
    /// Gets composite key properties that satisfy RequiredAttribute filtering per instance.
    /// </summary>
    private PropertyInfo[] GetFilteredKeyProperties()
    {
        Type type = GetType();

        PropertyInfo[] allKeyProps = KeyPropertiesCache.GetOrAdd(type, t =>
            t.GetProperties()
                .Where(p => p.GetCustomAttribute<CompositeKeyPartAttribute>() != null)
                .ToArray()
        );

        PropertyInfo[] filtered = allKeyProps
            .Where(p => 
                p.GetCustomAttribute<RequiredAttribute>() == null 
                || !string.IsNullOrEmpty(FormatValue(p.GetValue(this))))
            .ToArray();

        return filtered;
    }

    /// <summary>
    /// Gets lookup key property groups for this type.
    /// </summary>
    private Dictionary<string, (PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[]>
        GetLookupKeyProperties()
    {
        Type type = GetType();

        if (LookupKeyPropertiesCache.TryGetValue(type, out var lookupGroups))
            return lookupGroups;

        PropertyInfo[] allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);

        Dictionary<string, (PropertyInfo Prop, LookupCompositeKeyPartAttribute Attr)[]> groups =
            allProps
                .SelectMany(p => p.GetCustomAttributes<LookupCompositeKeyPartAttribute>()
                    .Select(attr => (Prop: p, Attr: attr)))
                .GroupBy(x => x.Attr.TargetPropertyName)
                .ToDictionary(g => g.Key, g => g.ToArray());

        Dictionary<string, PropertyInfo> targetProps = allProps
            .Where(p => p.PropertyType == typeof(UInt128) || p.PropertyType == typeof(UInt128?))
            .ToDictionary(p => p.Name, p => p);

        LookupKeyPropertiesCache[type] = groups;
        LookupKeyTargetPropertiesCache[type] = targetProps;

        return groups;
    }

    /// <summary>
    /// Gets public instance properties declared on the derived class (not ImportModel).
    /// </summary>
    private PropertyInfo[] GetOwnProperties()
    {
        Type type = GetType();

        if (OwnPropertiesCache.TryGetValue(type, out PropertyInfo[]? props))
            return props;

        props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.DeclaringType != typeof(ImportModel))
            .ToArray();

        OwnPropertiesCache[type] = props;
        return props;
    }

    private static string GetKeyToken(PropertyInfo p, object instance)
    {
        CompositeKeyPartAttribute? attr = p.GetCustomAttribute<CompositeKeyPartAttribute>();
        string id = attr?.PartId ?? p.Name;   
        return $"{id}:{FormatValue(p.GetValue(instance))}";
    }
    
    private static string GetKeyTokenForLookupGroup(PropertyInfo p, LookupCompositeKeyPartAttribute attr, object instance)
    {
        string id = attr.PartId;
        return $"{id}:{FormatValue(p.GetValue(instance))}";
    }
    
    /// <summary>
    /// Sets the lookup key property value on this instance.
    /// </summary>
    private void SetLookupKeyValue(string targetPropertyName, UInt128? value)
    {
        if (LookupKeyTargetPropertiesCache.TryGetValue(GetType(), out Dictionary<string, PropertyInfo>? targetProperties) &&
            targetProperties.TryGetValue(targetPropertyName, out PropertyInfo? targetProperty))
        {
            targetProperty.SetValue(this, value);
        }
    }

    /// <summary>
    /// Computes a UInt128 hash from string array input.
    /// </summary>
    private static UInt128 GenerateHash(string[] values)
    {
        byte[] input = Encoding.UTF8.GetBytes(string.Join("|", values));
        byte[] hashBytes = SHA256.HashData(input);

        ulong lower = BitConverter.ToUInt64(hashBytes, 0);
        ulong upper = BitConverter.ToUInt64(hashBytes, 8);

        return (UInt128)upper << 64 | lower;
    }

    /// <summary>
    /// Generates a cryptographically random UInt128 value.
    /// </summary>
    private static UInt128 GenerateRandomUInt128()
    {
        Span<byte> bytes = stackalloc byte[16];
        RandomNumberGenerator.Fill(bytes);

        ulong low = BitConverter.ToUInt64(bytes[..8]);
        ulong high = BitConverter.ToUInt64(bytes[8..]);

        return ((UInt128)high << 64) | low;
    }

    /// <summary>
    /// Formats various common types for key string generation.
    /// </summary>
    private static string FormatValue(object? value)
    {
        return value switch
        {
            decimal decimalValue => decimalValue.ToString(TabellaConstants.DecimalFormat),
            DateTime dateTimeValue => dateTimeValue.ToString(TabellaConstants.DateFormat),
            Enum enumValue => enumValue.ToString(),
            bool boolValue => boolValue ? TabellaConstants.StringBoolTrue : TabellaConstants.StringBoolFalse,
            _ => value?.ToString()?.Trim() ?? string.Empty
        };
    }
    
    private sealed record KeyBuildResult(
        UInt128? Key,
        string[] HeaderNames
    );
}